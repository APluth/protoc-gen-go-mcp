// Code generated by protoc-gen-mcp-go. DO NOT EDIT.
// source: testdata/selective_generation_test.proto

package testdatamcp

import (
	testdata "github.com/redpanda-data/protoc-gen-go-mcp/pkg/testdata/gen/go-golden/testdata"
)

import (
	"context"
	"github.com/mark3labs/mcp-go/mcp"
	mcpserver "github.com/mark3labs/mcp-go/server"
	"encoding/json"
	"google.golang.org/protobuf/encoding/protojson"
	"connectrpc.com/connect"
	grpc "google.golang.org/grpc"
	"github.com/redpanda-data/protoc-gen-go-mcp/pkg/runtime"
)

var (
	SelectiveService_AnotherEnabledMethodTool       = mcp.Tool{Meta: (*mcp.Meta)(nil), Name: "testdata_SelectiveService_AnotherEnabledMethod", Description: "AnotherEnabledMethod should generate MCP endpoints with additional description\n", InputSchema: mcp.ToolInputSchema{Defs: map[string]interface{}(nil), Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}, RawOutputSchema: json.RawMessage(nil), Annotations: mcp.ToolAnnotation{Title: "", ReadOnlyHint: (*bool)(nil), DestructiveHint: (*bool)(nil), IdempotentHint: (*bool)(nil), OpenWorldHint: (*bool)(nil)}}
	SelectiveService_EnabledMethodTool              = mcp.Tool{Meta: (*mcp.Meta)(nil), Name: "testdata_SelectiveService_EnabledMethod", Description: "EnabledMethod should generate MCP endpoints\n", InputSchema: mcp.ToolInputSchema{Defs: map[string]interface{}(nil), Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}, RawOutputSchema: json.RawMessage(nil), Annotations: mcp.ToolAnnotation{Title: "", ReadOnlyHint: (*bool)(nil), DestructiveHint: (*bool)(nil), IdempotentHint: (*bool)(nil), OpenWorldHint: (*bool)(nil)}}
	SelectiveService_AnotherEnabledMethodToolOpenAI = mcp.Tool{Meta: (*mcp.Meta)(nil), Name: "testdata_SelectiveService_AnotherEnabledMethod", Description: "AnotherEnabledMethod should generate MCP endpoints with additional description\n", InputSchema: mcp.ToolInputSchema{Defs: map[string]interface{}(nil), Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x22, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}, RawOutputSchema: json.RawMessage(nil), Annotations: mcp.ToolAnnotation{Title: "", ReadOnlyHint: (*bool)(nil), DestructiveHint: (*bool)(nil), IdempotentHint: (*bool)(nil), OpenWorldHint: (*bool)(nil)}}
	SelectiveService_EnabledMethodToolOpenAI        = mcp.Tool{Meta: (*mcp.Meta)(nil), Name: "testdata_SelectiveService_EnabledMethod", Description: "EnabledMethod should generate MCP endpoints\n", InputSchema: mcp.ToolInputSchema{Defs: map[string]interface{}(nil), Type: "", Properties: map[string]interface{}(nil), Required: []string(nil)}, RawInputSchema: json.RawMessage{0x7b, 0x22, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x50, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x2c, 0x22, 0x70, 0x72, 0x6f, 0x70, 0x65, 0x72, 0x74, 0x69, 0x65, 0x73, 0x22, 0x3a, 0x7b, 0x22, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x22, 0x3a, 0x7b, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x7d, 0x7d, 0x2c, 0x22, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x22, 0x3a, 0x5b, 0x22, 0x69, 0x6e, 0x70, 0x75, 0x74, 0x22, 0x5d, 0x2c, 0x22, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3a, 0x22, 0x6f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x22, 0x7d}, RawOutputSchema: json.RawMessage(nil), Annotations: mcp.ToolAnnotation{Title: "", ReadOnlyHint: (*bool)(nil), DestructiveHint: (*bool)(nil), IdempotentHint: (*bool)(nil), OpenWorldHint: (*bool)(nil)}}
)

// SelectiveServiceServer is compatible with the grpc-go server interface.
type SelectiveServiceServer interface {
	AnotherEnabledMethod(ctx context.Context, req *testdata.AnotherEnabledRequest) (*testdata.AnotherEnabledResponse, error)
	EnabledMethod(ctx context.Context, req *testdata.EnabledRequest) (*testdata.EnabledResponse, error)
}

// RegisterSelectiveServiceHandler registers standard MCP handlers for SelectiveService
func RegisterSelectiveServiceHandler(s *mcpserver.MCPServer, srv SelectiveServiceServer, opts ...runtime.Option) {
	config := runtime.NewConfig()
	for _, opt := range opts {
		opt(config)
	}
	AnotherEnabledMethodTool := SelectiveService_AnotherEnabledMethodTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		AnotherEnabledMethodTool = runtime.AddExtraPropertiesToTool(AnotherEnabledMethodTool, config.ExtraProperties)
	}

	s.AddTool(AnotherEnabledMethodTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req testdata.AnotherEnabledRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.AnotherEnabledMethod(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
	EnabledMethodTool := SelectiveService_EnabledMethodTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		EnabledMethodTool = runtime.AddExtraPropertiesToTool(EnabledMethodTool, config.ExtraProperties)
	}

	s.AddTool(EnabledMethodTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req testdata.EnabledRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.EnabledMethod(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
}

// RegisterSelectiveServiceHandlerOpenAI registers OpenAI-compatible MCP handlers for SelectiveService
func RegisterSelectiveServiceHandlerOpenAI(s *mcpserver.MCPServer, srv SelectiveServiceServer, opts ...runtime.Option) {
	config := runtime.NewConfig()
	for _, opt := range opts {
		opt(config)
	}
	AnotherEnabledMethodToolOpenAI := SelectiveService_AnotherEnabledMethodToolOpenAI
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		AnotherEnabledMethodToolOpenAI = runtime.AddExtraPropertiesToTool(AnotherEnabledMethodToolOpenAI, config.ExtraProperties)
	}

	s.AddTool(AnotherEnabledMethodToolOpenAI, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req testdata.AnotherEnabledRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		runtime.FixOpenAI(req.ProtoReflect().Descriptor(), message)

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.AnotherEnabledMethod(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
	EnabledMethodToolOpenAI := SelectiveService_EnabledMethodToolOpenAI
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		EnabledMethodToolOpenAI = runtime.AddExtraPropertiesToTool(EnabledMethodToolOpenAI, config.ExtraProperties)
	}

	s.AddTool(EnabledMethodToolOpenAI, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req testdata.EnabledRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		runtime.FixOpenAI(req.ProtoReflect().Descriptor(), message)

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.EnabledMethod(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}

		return mcp.NewToolResultText(string(marshaled)), nil
	})
}

// RegisterSelectiveServiceHandlerWithProvider registers handlers for the specified LLM provider
func RegisterSelectiveServiceHandlerWithProvider(s *mcpserver.MCPServer, srv SelectiveServiceServer, provider runtime.LLMProvider, opts ...runtime.Option) {
	switch provider {
	case runtime.LLMProviderOpenAI:
		RegisterSelectiveServiceHandlerOpenAI(s, srv, opts...)
	case runtime.LLMProviderStandard:
		fallthrough
	default:
		RegisterSelectiveServiceHandler(s, srv, opts...)
	}
}

// SelectiveServiceClient is compatible with the grpc-go client interface.
type SelectiveServiceClient interface {
	AnotherEnabledMethod(ctx context.Context, req *testdata.AnotherEnabledRequest, opts ...grpc.CallOption) (*testdata.AnotherEnabledResponse, error)
	EnabledMethod(ctx context.Context, req *testdata.EnabledRequest, opts ...grpc.CallOption) (*testdata.EnabledResponse, error)
}

// ConnectSelectiveServiceClient is compatible with the connectrpc-go client interface.
type ConnectSelectiveServiceClient interface {
	AnotherEnabledMethod(ctx context.Context, req *connect.Request[testdata.AnotherEnabledRequest]) (*connect.Response[testdata.AnotherEnabledResponse], error)
	EnabledMethod(ctx context.Context, req *connect.Request[testdata.EnabledRequest]) (*connect.Response[testdata.EnabledResponse], error)
}

// ForwardToConnectSelectiveServiceClient registers a connectrpc client, to forward MCP calls to it.
func ForwardToConnectSelectiveServiceClient(s *mcpserver.MCPServer, client ConnectSelectiveServiceClient, opts ...runtime.Option) {
	config := runtime.NewConfig()
	for _, opt := range opts {
		opt(config)
	}
	AnotherEnabledMethodTool := SelectiveService_AnotherEnabledMethodTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		AnotherEnabledMethodTool = runtime.AddExtraPropertiesToTool(AnotherEnabledMethodTool, config.ExtraProperties)
	}

	s.AddTool(AnotherEnabledMethodTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req testdata.AnotherEnabledRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.AnotherEnabledMethod(ctx, connect.NewRequest(&req))
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	EnabledMethodTool := SelectiveService_EnabledMethodTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		EnabledMethodTool = runtime.AddExtraPropertiesToTool(EnabledMethodTool, config.ExtraProperties)
	}

	s.AddTool(EnabledMethodTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req testdata.EnabledRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.EnabledMethod(ctx, connect.NewRequest(&req))
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
}

// ForwardToSelectiveServiceClient registers a gRPC client, to forward MCP calls to it.
func ForwardToSelectiveServiceClient(s *mcpserver.MCPServer, client SelectiveServiceClient, opts ...runtime.Option) {
	config := runtime.NewConfig()
	for _, opt := range opts {
		opt(config)
	}
	AnotherEnabledMethodTool := SelectiveService_AnotherEnabledMethodTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		AnotherEnabledMethodTool = runtime.AddExtraPropertiesToTool(AnotherEnabledMethodTool, config.ExtraProperties)
	}

	s.AddTool(AnotherEnabledMethodTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req testdata.AnotherEnabledRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.AnotherEnabledMethod(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
	EnabledMethodTool := SelectiveService_EnabledMethodTool
	// Add extra properties to schema if configured
	if len(config.ExtraProperties) > 0 {
		EnabledMethodTool = runtime.AddExtraPropertiesToTool(EnabledMethodTool, config.ExtraProperties)
	}

	s.AddTool(EnabledMethodTool, func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		var req testdata.EnabledRequest

		message := request.GetArguments()

		// Extract extra properties if configured
		for _, prop := range config.ExtraProperties {
			if propVal, ok := message[prop.Name]; ok {
				ctx = context.WithValue(ctx, prop.ContextKey, propVal)
			}
		}

		marshaled, err := json.Marshal(message)
		if err != nil {
			return nil, err
		}

		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.EnabledMethod(ctx, &req)
		if err != nil {
			return runtime.HandleError(err)
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
	})
}
